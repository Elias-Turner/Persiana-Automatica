Stryker 24X
stryker24x
En una llamada

GoldenX86_64 — 02/04/2025 19:12
Stryker 24X — 02/04/2025 19:12
Stryker 24X
 ha iniciado una llamada que ha durado una hora. — 02/04/2025 19:12
Stryker 24X — 02/04/2025 19:35
https://www.youtube.com/watch?v=nTw2OlDl1N8
YouTube
ROOF PLUS SL VELUX instalador PRO
Funcionamiento persiana solar Velux
Imagen
https://www.youtube.com/watch?v=WCpN4cYicwQ
YouTube
TECNOLOSA
CORTINA-ARDUINO.ISMAEL-ISAAC; 4º ESO EL FOIX
Imagen
Stryker 24X — 02/04/2025 19:43
https://www.youtube.com/watch?v=kTxexQzdPPM&t=4s
YouTube
Sharon Rivas
PROYECTO: PUERTA ELECTRICA ENROLLABLE
Imagen
GoldenX86_64 — 02/04/2025 20:07
https://chat.deepseek.com/a/chat/s/2de7d0f4-63ec-40f1-bfd5-312685bae439
Para el **an谩lisis de alcance** del proyecto, es fundamental definir claramente los l铆mites, objetivos, requisitos y exclusiones del sistema. Aqu铆 tienes una estructura sugerida para el reporte, enfocada en los aspectos clave que debes incluir:

---

### **1. Objetivo Principal**
- **Prop贸sito del sistema**: Automatizar el subir/bajar cortinas usando un motor controlado por un Raspberry Pi, bas谩ndose en condiciones lum铆nicas (sensor de luz) y distancia (sensor ultras贸nico).
Expandir
message.txt
6 KB
GoldenX86_64
 ha iniciado una llamada que ha durado 10 minutos. — 02/04/2025 20:21
Stryker 24X — 06/04/2025 19:26
pi 3
servo motor amarillo
sensor de ultrasonido x2
sensor de luz
botón de accionamiento
l2943















https://www.youtube.com/watch?v=gOVQUapx4cU

https://www.youtube.com/watch?v=oDP4sDJvgBk

https://www.youtube.com/watch?v=_tZh0GKrkH8

https://www.youtube.com/watch?v=mJnMktEoCFQ

https://www.youtube.com/watch?v=cQVNoQGKh0g
YouTube
José Paulo Fuentes Lufer
Control Automático de Persiana con Arduino, motor DC y sensor de l...
Imagen
YouTube
MundoKaZ
Persiana Automatizada (Sensor de Luz)
Imagen
YouTube
ELECTRONOOBS en Español
Curso Arduino Nivel 2 - Clase 20: Proyecto Persiana automática
Imagen
YouTube
Manuel Jesús García Rodríguez
Circuito persiana automática (con LDR)
Imagen
YouTube
Epicdelia
Blind Automation based on Sunlight (for Noobs)
Imagen
GoldenX86_64
 ha iniciado una llamada que ha durado 38 minutos. — 06/04/2025 19:36
Stryker 24X
 ha iniciado una llamada que ha durado 2 horas. — 10/04/2025 21:16
Stryker 24X — 10/04/2025 21:22
Tipo de archivo adjunto: acrobat
Proyecto Sistemas Embebidos - Aviles - Bravo.pdf
228.10 KB
GoldenX86_64 — 10/04/2025 21:28
https://articulo.mercadolibre.com.ar/MLA-1136387298-kit-motor-automatico-tubular-blackout-persiana-cortina-toldo-_JM#polycard_client=search-nordic&position=11&search_layout=stack&type=item&tracking_id=0a87ef20-a12b-4789-8e26-54423d3b1ecb&wid=MLA1136387298&sid=search

https://articulo.mercadolibre.com.ar/MLA-1341025291-controlador-por-control-remoto-persiana-cortinas-blackout-_JM#polycard_client=search-nordic&position=6&search_layout=stack&type=item&tracking_id=0a87ef20-a12b-4789-8e26-54423d3b1ecb&wid=MLA1341025291&sid=search
Stryker 24X — 10/04/2025 21:31
[Inicio] 
   ↓ 
[Leer sensor de luz] 
   ↓
¿Luz > umbral?
   ↓       ↘
[Leer sensor ultrasónico ↑]    [Leer sensor ultrasónico ↓]
   ↓                              ↓
¿Abierta?                      ¿Cerrada?
   ↓                              ↓
[Activar motor subir]       [Activar motor bajar]
   ↓                              ↓
[Esperar hasta detenerse por sensor]
Raspberry Pi
     ├── Sensor LDR
     ├── Sensor Ultrasónico ↑
     ├── Sensor Ultrasónico ↓
     ├── Driver L293D ──> Motor
     └── Botón
persianas-automaticas-con-arduino-solucionado/364176
mandiyzone.wordpress/2016/08/28/persiana-automatica-arduino/
Stryker 24X — 10/04/2025 21:39
https://forum.arduino.cc/t/persianas-automaticas-con-arduino-solucionado/364176
Arduino Forum
Persianas automáticas con arduino Solucionado
Hola, he visto post que tratan este tema pero también he visto que no reabrir post viejos...por eso este nuevo. Bueno llevo poco tiempo con arduino,me he mudado y la casa tiene en el salon persianas mecanicas con dos botones uno para bajar y otro subir. Ya tengo mi arduino con dos relés y un sensor de luz, estoy probando con dos leds a los r...
https://mandiyzone.wordpress.com/2016/08/28/persiana-automatica-arduino/
Man DIY
Man DIY
Persiana automática con sensor de luz controlada con Arduino.
Hola de nuevo! este es un proyecto que tiene su trabajo pero después de ver el resultado final merece la pena. Las persianas del salón funcionan con motor, tiene dos botones para subir o bajar, no …
Persiana automática con sensor de luz controlada con Arduino.
GoldenX86_64 — 10/04/2025 21:42
Imagen
Imagen
Imagen
Stryker 24X — 10/04/2025 22:19
Componente    Precio Aproximado (ARS)    Observaciones
Raspberry Pi 3 Model B+    $78.000 – $126.000    Varía según si se adquiere solo o en kit con accesorios. ​
Mercado Libre
Sensor de luz (LDR)    $200 – $500    Sensor básico para detección de luz ambiental.​
Sensor ultrasónico HC-SR04    $1.000 – $2.000    Precio por unidad; se requieren dos para el proyecto.​
Servo motor amarillo (SG90)    $1.500 – $3.000    Servo motor estándar para proyectos de automatización.​
Driver L293D    $1.000 – $2.500    Módulo para control de motores DC y servos.​
Fuente de alimentación (5V o 12V)    $2.000 – $5.000    Dependiendo de la corriente requerida por el motor y la Raspberry Pi.​
Poleas o engranajes    $1.000 – $3.000    Precio estimado para componentes mecánicos básicos.​
Mercado Libre
Cables y conectores    $500 – $1.500    Incluye cables Dupont, jumpers y conectores varios.​
Botón físico    $100 – $300    Botón pulsador simple para entrada manual.
GoldenX86_64 — 20:08
cuando quieras
Stryker 24X
 ha iniciado una llamada. — 20:30
Stryker 24X — 20:30
ya estoy
https://github.com/Elias-Turner/Persiana-Automatica.git
Stryker 24X — 20:37
https://github.com/Elias-Turner/Persiana-Automatica
GoldenX86_64 — 20:38
import RPi.GPIO as GPIO
import time

# Configuración de pines
LDR_PIN = 17    # Sensor de luz (LDR)
TRIG_SUP = 23   # Sensor ultrasónico superior
ECHO_SUP = 24
TRIG_INF = 27   # Sensor ultrasónico inferior
ECHO_INF = 22
MOTOR_IN1 = 5   # Control motor
MOTOR_IN2 = 6

# Constantes configurables
DISTANCIA_MIN = 5.0    # Distancia mínima válida (cm)
DISTANCIA_MAX = 100.0  # Distancia máxima válida (cm)
UMBRAL_LUZ = 0.5       # Umbral luz/oscuridad (0-1)
TIEMPO_ESPERA = 0.1    # Tiempo entre lecturas (segundos)
DISTANCIA_PARADA_SUP = 20.0  # Distancia para detener en superior
DISTANCIA_PARADA_INF = 20.0  # Distancia para detener en inferior
INTENTOS_LECTURA = 5    # Intentos para lectura válida

# Configuración de GPIO
GPIO.setmode(GPIO.BCM)
GPIO.setup(LDR_PIN, GPIO.IN)
GPIO.setup(TRIG_SUP, GPIO.OUT)
GPIO.setup(ECHO_SUP, GPIO.IN)
GPIO.setup(TRIG_INF, GPIO.OUT)
GPIO.setup(ECHO_INF, GPIO.IN)
GPIO.setup(MOTOR_IN1, GPIO.OUT)
GPIO.setup(MOTOR_IN2, GPIO.OUT)

# Inicializar motor apagado
GPIO.output(MOTOR_IN1, GPIO.LOW)
GPIO.output(MOTOR_IN2, GPIO.LOW)

def medir_distancia(trig, echo):
    """Mide distancia con sensor ultrasónico con validación de errores"""
    for _ in range(INTENTOS_LECTURA):
        GPIO.output(trig, True)
        time.sleep(0.00001)
        GPIO.output(trig, False)
        
        timeout = time.time() + 0.04  # Timeout de 40ms
        while GPIO.input(echo) == 0 and time.time() < timeout:
            pulso_inicio = time.time()
        
        timeout = time.time() + 0.04
        while GPIO.input(echo) == 1 and time.time() < timeout:
            pulso_fin = time.time()
        
        try:
            duracion = pulso_fin - pulso_inicio
            distancia = (duracion * 34300) / 2  # Velocidad del sonido (343 m/s)
            
            if DISTANCIA_MIN <= distancia <= DISTANCIA_MAX:
                return distancia
        except UnboundLocalError:
            pass
    
    return None  # Retorna None si todas las lecturas fallan

def control_motor(accion):
    """Controla el motor con protección contra activación simultánea"""
    GPIO.output(MOTOR_IN1, GPIO.LOW)
    GPIO.output(MOTOR_IN2, GPIO.LOW)
    time.sleep(0.05)  # Breve pausa para evitar cortocircuitos
    
    if accion == "subir":
        GPIO.output(MOTOR_IN1, GPIO.HIGH)
        GPIO.output(MOTOR_IN2, GPIO.LOW)
    elif accion == "bajar":
        GPIO.output(MOTOR_IN1, GPIO.LOW)
        GPIO.output(MOTOR_IN2, GPIO.HIGH)
    elif accion == "detener":
        GPIO.output(MOTOR_IN1, GPIO.LOW)
        GPIO.output(MOTOR_IN2, GPIO.LOW)

def leer_luz():
    """Lee el sensor de luz con filtro antirrebote"""
    lecturas = [GPIO.input(LDR_PIN) for _ in range(5)]
    return sum(lecturas) / len(lecturas) > UMBRAL_LUZ

# Variables de estado
estado_actual = "detenido"
ultimo_cambio = time.time()

try:
    while True:
        # 1. Leer condiciones ambientales
        hay_luz = leer_luz()
        
        # 2. Medir distancias con manejo de errores
        dist_sup = medir_distancia(TRIG_SUP, ECHO_SUP)
        dist_inf = medir_distancia(TRIG_INF, ECHO_INF)
        
        # 3. Lógica de control principal
        if hay_luz and estado_actual != "subiendo":
            if dist_sup is not None and dist_sup > DISTANCIA_PARADA_SUP:
                control_motor("subir")
                estado_actual = "subiendo"
... (24 líneas restantes)
Contraer
message.txt
5 KB
Stryker 24X — 20:44
ff
Stryker 24X — 20:58
Imagen
Imagen
+3.3V --- LDR ---+--- 10kΩ --- GND
                 |
              Entrada CH0 del MCP3008
GoldenX86_64 — 21:37
import RPi.GPIO as GPIO
import time

# Configuración de pines
LDR_PIN = 17    # Sensor de luz (LDR)
TRIG_SUP = 23   # Sensor ultrasónico superior
Expandir
message.txt
7 KB
Stryker 24X — 21:54
Alternativa sin ADC:
Si no tenés un MCP3008, podés usar un truco digital para detectar variaciones de luz:

⚙️ Método de carga de condensador:
Armás un circuito con un condensador y el LDR.

Cargás el pin como salida y lo ponés en HIGH.

Lo cambiás a entrada y medís cuánto tarda en descargarse.

Esa demora depende de la resistencia del LDR, que varía con la luz.

Pero este método:

No es muy preciso.

No da un valor en lux.

Requiere código especial y calibración.
+3.3V
       |
       |
      [ LDR ]
       |
       |------ GPIO (ej: GPIO 18) ← mide descarga
       |
      ===
     |   | Condensador (ej: 10μF)
     ===
      |
     GND
import RPi.GPIO as GPIO
import time

LDR_PIN = 18  # Elegí un pin GPIO libre

GPIO.setmode(GPIO.BCM)
GPIO.setup(LDR_PIN, GPIO.OUT)

def descargar():
    GPIO.setup(LDR_PIN, GPIO.OUT)
    GPIO.output(LDR_PIN, False)
    time.sleep(0.1)

def medir_carga():
    descarga_time = 0
    GPIO.setup(LDR_PIN, GPIO.IN)

Contamos el tiempo hasta que el pin se vuelva LOW,
    while GPIO.input(LDR_PIN) == GPIO.HIGH and descarga_time < 10000:
        descarga_time += 1

    return descarga_time

try:
    while True:
        descargar()
        lectura = medir_carga()
        print(f"Luz relativa: {lectura}")
        time.sleep(1)

except KeyboardInterrupt:
    GPIO.cleanup()
GoldenX86_64 — 22:06
import RPi.GPIO as GPIO
import time
import sys
import select

# Configuración de pines
Expandir
message.txt
9 KB
﻿
import RPi.GPIO as GPIO
import time
import sys
import select

# Configuración de pines
TRIG_SUP = 23   # Sensor ultrasónico superior
ECHO_SUP = 24
TRIG_INF = 27   # Sensor ultrasónico inferior
ECHO_INF = 22
MOTOR_IN1 = 5   # Control motor
MOTOR_IN2 = 6

# Constantes configurables
DISTANCIA_MIN = 5.0    # Distancia mínima válida (cm)
DISTANCIA_MAX = 100.0  # Distancia máxima válida (cm)
DISTANCIA_PARADA_SUP = 15.0  # Distancia para detener en superior
DISTANCIA_PARADA_INF = 15.0  # Distancia para detener en inferior
INTENTOS_LECTURA = 3    # Intentos para lectura válida
TIEMPO_ESPERA = 0.1    # Tiempo entre lecturas (segundos)

# Configuración de GPIO
GPIO.setmode(GPIO.BCM)
GPIO.setup(TRIG_SUP, GPIO.OUT)
GPIO.setup(ECHO_SUP, GPIO.IN)
GPIO.setup(TRIG_INF, GPIO.OUT)
GPIO.setup(ECHO_INF, GPIO.IN)
GPIO.setup(MOTOR_IN1, GPIO.OUT)
GPIO.setup(MOTOR_IN2, GPIO.OUT)

# Inicializar motor apagado
GPIO.output(MOTOR_IN1, GPIO.LOW)
GPIO.output(MOTOR_IN2, GPIO.LOW)

# Estados del motor
MOTOR_DETENIDO = 0
MOTOR_SUBIENDO = 1
MOTOR_BAJANDO = 2
estado_motor = MOTOR_DETENIDO

def medir_distancia(trig, echo, sensor_nombre):
    """Mide distancia con sensor ultrasónico con validación de errores"""
    for i in range(INTENTOS_LECTURA):
        GPIO.output(trig, True)
        time.sleep(0.00001)
        GPIO.output(trig, False)
        
        timeout = time.time() + 0.04  # Timeout de 40ms
        pulso_inicio = None
        while GPIO.input(echo) == 0 and time.time() < timeout:
            pulso_inicio = time.time()
        
        timeout = time.time() + 0.04
        pulso_fin = None
        while GPIO.input(echo) == 1 and time.time() < timeout:
            pulso_fin = time.time()
        
        if pulso_inicio is None or pulso_fin is None:
            continue
        
        try:
            duracion = pulso_fin - pulso_inicio
            distancia = (duracion * 34300) / 2  # Velocidad del sonido (343 m/s)
            
            if DISTANCIA_MIN <= distancia <= DISTANCIA_MAX:
                return distancia
        except:
            pass
    
    return None

def determinar_posicion(dist_sup, dist_inf):
    """Determina la posición actual basada en lecturas de sensores"""
    # Verificar si la cortina está en posición superior
    if dist_sup is not None and dist_sup <= DISTANCIA_PARADA_SUP:
        return "superior"
    
    # Verificar si la cortina está en posición inferior
    if dist_inf is not None and dist_inf <= DISTANCIA_PARADA_INF:
        return "inferior"
    
    # Si no está en ninguno de los topes
    return "intermedia"

def control_motor(accion):
    """Controla el motor con protección contra activación simultánea"""
    global estado_motor
    
    # Apagar ambos pines primero para evitar cortocircuitos
    GPIO.output(MOTOR_IN1, GPIO.LOW)
    GPIO.output(MOTOR_IN2, GPIO.LOW)
    time.sleep(0.05)  # Breve pausa de seguridad
    
    if accion == "subir":
        GPIO.output(MOTOR_IN1, GPIO.HIGH)
        GPIO.output(MOTOR_IN2, GPIO.LOW)
        estado_motor = MOTOR_SUBIENDO
        print("[MOTOR] Subiendo cortina")
        
    elif accion == "bajar":
        GPIO.output(MOTOR_IN1, GPIO.LOW)
        GPIO.output(MOTOR_IN2, GPIO.HIGH)
        estado_motor = MOTOR_BAJANDO
        print("[MOTOR] Bajando cortina")
        
    elif accion == "detener":
        GPIO.output(MOTOR_IN1, GPIO.LOW)
        GPIO.output(MOTOR_IN2, GPIO.LOW)
        estado_motor = MOTOR_DETENIDO
        print("[MOTOR] Motor detenido")

def imprimir_estado(dist_sup, dist_inf, posicion):
    """Muestra el estado actual del sistema"""
    print("\n" + "="*50)
    print("ESTADO DEL SISTEMA")
    print("="*50)
    
    # Mostrar lecturas de sensores
    if dist_sup is not None:
        print(f"Distancia superior: {dist_sup:.1f} cm")
    else:
        print("Distancia superior: ERROR")
        
    if dist_inf is not None:
        print(f"Distancia inferior: {dist_inf:.1f} cm")
    else:
        print("Distancia inferior: ERROR")
    
    # Mostrar posición determinada
    print(f"Posición estimada: {posicion.upper()}")
    
    # Mostrar estado del motor
    estados = {
        MOTOR_DETENIDO: "DETENIDO",
        MOTOR_SUBIENDO: "SUBIENDO",
        MOTOR_BAJANDO: "BAJANDO"
    }
    print(f"Estado motor: {estados[estado_motor]}")
    
    print("="*50)
    print("Comandos: A=Alternar, S=Detener, Q=Salir")
    print("="*50 + "\n")

def leer_teclado():
    """Verifica si hay entrada de teclado disponible (no bloqueante)"""
    if select.select([sys.stdin], [], [], 0)[0]:
        return sys.stdin.read(1)
    return None

# Mensaje inicial
print("\n" + "="*50)
print("SISTEMA DE CORTINA CON DETERMINACIÓN EN TIEMPO REAL")
print("="*50)
print("Configuración:")
print(f"- Distancia parada superior: {DISTANCIA_PARADA_SUP} cm")
print(f"- Distancia parada inferior: {DISTANCIA_PARADA_INF} cm")
print("="*50)

try:
    contador_actualizacion = 0
    while True:
        # Leer sensores
        dist_sup = medir_distancia(TRIG_SUP, ECHO_SUP, "SUPERIOR")
        dist_inf = medir_distancia(TRIG_INF, ECHO_INF, "INFERIOR")
        
        # Determinar posición actual
        posicion_actual = determinar_posicion(dist_sup, dist_inf)
        
        # Actualizar estado cada 5 ciclos
        contador_actualizacion += 1
        if contador_actualizacion >= 5:
            imprimir_estado(dist_sup, dist_inf, posicion_actual)
            contador_actualizacion = 0
        
        # Leer entrada de teclado
        tecla = leer_teclado()
        
        # Procesar comandos
        if tecla == 'a' or tecla == 'A':
            print("\n[COMANDO] Tecla 'A' presionada - Alternando movimiento")
            
            # Determinar acción basada en posición actual
            if posicion_actual == "superior":
                print("[LOGICA] Cortina en TOPE SUPERIOR - Bajando")
                control_motor("bajar")
                
            elif posicion_actual == "inferior":
                print("[LOGICA] Cortina en TOPE INFERIOR - Subiendo")
                control_motor("subir")
                
            elif posicion_actual == "intermedia":
                # Si está en posición intermedia, alternar dirección
                if estado_motor == MOTOR_SUBIENDO:
                    print("[LOGICA] Cortina INTERMEDIA - Cambiando a BAJAR")
                    control_motor("bajar")
                elif estado_motor == MOTOR_BAJANDO:
                    print("[LOGICA] Cortina INTERMEDIA - Cambiando a SUBIR")
                    control_motor("subir")
                else:
                    # Por defecto subir si está detenido en medio
                    print("[LOGICA] Cortina INTERMEDIA - Iniciando SUBIDA")
                    control_motor("subir")
                    
        elif tecla == 's' or tecla == 'S':
            print("\n[COMANDO] Tecla 'S' presionada - Deteniendo motor")
            control_motor("detener")
            
        elif tecla == 'q' or tecla == 'Q':
            print("\n[COMANDO] Tecla 'Q' presionada - Saliendo del programa")
            break
        
        # Verificar límites durante movimiento
        if estado_motor == MOTOR_SUBIENDO:
            if dist_sup is not None and dist_sup <= DISTANCIA_PARADA_SUP:
                print("[LÍMITE] Cortina alcanzó tope SUPERIOR")
                control_motor("detener")
                
        elif estado_motor == MOTOR_BAJANDO:
            if dist_inf is not None and dist_inf <= DISTANCIA_PARADA_INF:
                print("[LÍMITE] Cortina alcanzó tope INFERIOR")
                control_motor("detener")
        
        time.sleep(TIEMPO_ESPERA)

except KeyboardInterrupt:
    print("\nPrograma interrumpido por el usuario")
finally:
    print("\nDeteniendo motor y limpiando GPIO...")
    control_motor("detener")
    GPIO.cleanup()
    print("Limpieza completada. Programa terminado.")
